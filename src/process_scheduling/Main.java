package process_scheduling;

import process_scheduling.algorithms.FCFS;
import process_scheduling.algorithms.RoundRobin;
import process_scheduling.algorithms.SRTF;
import process_scheduling.process.Process;

import java.io.IOException;
import java.io.StringWriter;
import java.util.Random;

public class Main {

    static final int PROCESS_COUNT = 50000;

    /**
     * {@code Float} number representing how long each processor cycles takes time. Can be interpreted as a processor's "speed".
     */
    static final float DELTA = 1f;

    /**
     * Threshold value for generating a new {@link Process}.
     */
    static final float ADDITION_THRESHOLD = 0.6f;

    /**
     * Offset value for {@link Random}.
     */
    static final int RANDOM_OFFSET = 0;

    static final ResultBuilder rb = new ResultBuilder();

    public static void main(String[] args) {

        int constant = 1000;

        for (int i = 1; i * constant <= PROCESS_COUNT; i++) {
            simulate(i * constant);
            System.out.println(i + ". Finished " + i * constant + " processes.");
        }

        try {
            rb.createFile("src/process_scheduling/results/resultWP");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Based on a seed returns a boolean value whether a process should be added or not.
     * @param seed a seed for RNG
     * @return {@code true} if number generated by RNG is larger than {@code ADDITION_THRESHOLD}
     */
    public static boolean shouldAddProcess(int seed) {
        Random r = new Random(seed + RANDOM_OFFSET);
        return r.nextFloat() > ADDITION_THRESHOLD;
    }

    private static void simulate(int processCount) {

        int currentTime = 0;

        FCFS fcfs = new FCFS();
        int fcfsProcessesLeft = processCount;
        boolean fcfsFinished = false;

        SRTF srtf = new SRTF();
        int srtfProcessesLeft = processCount;
        boolean srtfFinished = false;

        RoundRobin rr = new RoundRobin();
        int rrProcessesLeft = processCount;
        boolean rrFinished = false;

        // Main Loop
        while (!(fcfsFinished) || !(srtfFinished) || !(rrFinished) ) {

            // Randomly add process to each scheduling algorithm based on currentTime as seed
            if (shouldAddProcess(currentTime)) {

                if (fcfsProcessesLeft > 0) {
                    fcfs.getQueue().addProcess(Process.randomProcess(currentTime + RANDOM_OFFSET));
                    fcfsProcessesLeft--;
                }

                if (srtfProcessesLeft > 0) {
                    srtf.getQueue().addProcess(Process.randomProcess(currentTime + RANDOM_OFFSET));
                    srtfProcessesLeft--;
                }

                if (rrProcessesLeft > 0) {
                    rr.getQueue().addProcess(Process.randomProcess(currentTime + RANDOM_OFFSET));
                    rrProcessesLeft--;
                }

            }

            if (!fcfsFinished)
                fcfs.run(DELTA);

            if (!srtfFinished)
                srtf.run(DELTA);

            if (!rrFinished)
                rr.run(DELTA);

            if (fcfsProcessesLeft == 0 && fcfs.finished()) {
                fcfsFinished = true;
            }
            if (srtfProcessesLeft == 0 && srtf.finished()) {
                srtfFinished = true;
            }
            if (rrProcessesLeft == 0 && rr.finished()) {
                rrFinished = true;
            }

            currentTime++;

        }

//        System.out.println("===== FCFS =====");
//        System.out.println("Finished in " + fcfs.getCycles() + " cycles.");
//        System.out.println("FCFS average execution time: " + ( fcfs.getData().totalExecutionTime / processCount) );
//        System.out.println("FCFS average waiting time: " + ( fcfs.getData().totalWaitingTime / processCount) );
//        System.out.println("FCFS process switches: " + fcfs.getData().switches);
//        System.out.println("FCFS average amount of processes finished in " + SimulationData.CYCLES_COUNT + " cycles: " + fcfs.getData().getAverageFinishedProcessAmount() );
//
//        System.out.println("===== SRTF =====");
//        System.out.println("Finished in " + srtf.getCycles() + " cycles.");
//        System.out.println("SRTF average execution time: " + ( srtf.getData().totalExecutionTime / processCount) );
//        System.out.println("SRTF average waiting time: " + ( srtf.getData().totalWaitingTime / processCount) );
//        System.out.println("SRTF starving processes: " + srtf.getData().starvedProcesses);
//        System.out.println("SRTF process switches: " + srtf.getData().switches);
//        System.out.println("SRTF average amount of processes finished in " + SimulationData.CYCLES_COUNT + " cycles: " + srtf.getData().getAverageFinishedProcessAmount() );
//
//        System.out.println("===== Round Robin =====");
//        System.out.println("Finished in " + rr.getCycles() + " cycles.");
//        System.out.println("RR average execution time: " + ( rr.getData().totalExecutionTime / processCount) );
//        System.out.println("RR average waiting time: " + ( rr.getData().totalWaitingTime / processCount) );
//        System.out.println("RR average processor access time: " + ( rr.getData().totalProcessorAccessTime / processCount) );
//        System.out.println("RR process switches: " + rr.getData().switches);
//        System.out.println("RR average amount of processes finished in " + SimulationData.CYCLES_COUNT + " cycles: " + rr.getData().getAverageFinishedProcessAmount() );

        rb.append(processCount, fcfs.getData(), srtf.getData(), rr.getData());

    }

}
