package process_scheduling;

import process_scheduling.algorithms.FCFS;
import process_scheduling.algorithms.SRTF;
import process_scheduling.process.Process;

import java.util.Random;

public class Main {

    static final int PROCESS_SIZE = 1000;

    /**
     * {@code Float} number representing how long each processor cycles takes time. Can be interpreted as a processor's "speed".
     */
    static final float DELTA = 1f;

    /**
     * Threshold value for generating a new {@link Process}.
     */
    static final float ADDITION_THRESHOLD = 0.6f;

    /**
     * Offset value for {@link Random}.
     */
    static final int RANDOM_OFFSET = 0;

    static FCFS fcfs = new FCFS();
    static int fcfsProcessesLeft = PROCESS_SIZE;

    static SRTF srtf = new SRTF();
    static int srtfProcessesLeft = PROCESS_SIZE;

    /**
     * An {@link Integer} value that tracks how many processor cycles have already passed.
     */
    static int currentTime = 1;

    public static void main(String[] args) {

        // Main Loop
        while ((fcfsProcessesLeft > 0 || !fcfs.getQueue().isEmpty()) && (srtfProcessesLeft > 0 || !srtf.getQueue().isEmpty())) {

            // Randomly add process to each scheduling algorithm based on currentTime as seed
            if (shouldAddProcess(currentTime)) {

                // Get a random process based on currentTime as seed
                Process process = Process.randomProcess(currentTime + RANDOM_OFFSET);

                //region If algorithms still have processes to be added, add them

                if (fcfsProcessesLeft > 0) {
                    fcfs.getQueue().addProcess(process);
                    fcfsProcessesLeft--;
                }

                if (srtfProcessesLeft > 0) {
                    srtf.getQueue().addProcess(process);
                    srtfProcessesLeft--;
                }

                //endregion

            }

            fcfs.run(DELTA);
            srtf.run(DELTA);

            currentTime++;

        }

        System.out.println("FCFS average execution time: " + ( fcfs.getData().totalExecutionTime / PROCESS_SIZE ));
        System.out.println("FCFS average waiting time: " + ( fcfs.getData().totalWaitingTime / PROCESS_SIZE ) );
        System.out.println("=======================");
        System.out.println("SRTF average execution time: " + ( srtf.getData().totalExecutionTime / PROCESS_SIZE ));
        System.out.println("SRTF average waiting time: " + ( srtf.getData().totalWaitingTime / PROCESS_SIZE ) );
        System.out.println("=======================");
    }

    /**
     * Based on a seed returns a boolean value whether a process should be added or not.
     * @param seed a seed for RNG
     * @return {@code true} if number generated by RNG is larger than {@code ADDITION_THRESHOLD}
     */
    public static boolean shouldAddProcess(int seed) {
        Random r = new Random(seed + RANDOM_OFFSET);
        return r.nextFloat() > ADDITION_THRESHOLD;
    }

}
