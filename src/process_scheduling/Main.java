package process_scheduling;

import process_scheduling.algorithms.FCFS;
import process_scheduling.algorithms.RoundRobin;
import process_scheduling.algorithms.SRTF;
import process_scheduling.process.Process;

import java.util.Random;

public class Main {

    static final int PROCESS_COUNT = 5000;

    /**
     * {@code Float} number representing how long each processor cycles takes time. Can be interpreted as a processor's "speed".
     */
    static final float DELTA = 1f;

    /**
     * Threshold value for generating a new {@link Process}.
     */
    static final float ADDITION_THRESHOLD = 0.6f;

    /**
     * Offset value for {@link Random}.
     */
    static final int RANDOM_OFFSET = 0;

    static FCFS fcfs = new FCFS();
    static int fcfsProcessesLeft = PROCESS_COUNT;
    static int fcfsCycles = 0;
    static boolean fcfsFinished = false;

    static SRTF srtf = new SRTF();
    static int srtfProcessesLeft = PROCESS_COUNT;
    static int srtfCycles = 0;
    static boolean srtfFinished = false;

    static RoundRobin rr = new RoundRobin();
    static int rrProcessesLeft = PROCESS_COUNT;
    static int rrCycles = 0;
    static boolean rrFinished = false;

    /**
     * An {@link Integer} value that tracks how many processor cycles have already passed.
     */
    static int currentTime = 1;

    public static void main(String[] args) {

        // Main Loop
        while (!(fcfsFinished) || !(srtfFinished) || !(rrFinished) ) {

            // Randomly add process to each scheduling algorithm based on currentTime as seed
            if (shouldAddProcess(currentTime)) {

                // Get a random process based on currentTime as seed
                Process process = Process.randomProcess(currentTime + RANDOM_OFFSET);

                if (fcfsProcessesLeft > 0) {
                    fcfs.getQueue().addProcess(process);
                    fcfsProcessesLeft--;
                }

                if (srtfProcessesLeft > 0) {
                    srtf.getQueue().addProcess(process);
                    srtfProcessesLeft--;
                }

                if (rrProcessesLeft > 0) {
                    rr.getQueue().addProcess(process);
                    rrProcessesLeft--;
                }

            }

            if (!fcfsFinished)
                fcfs.run(DELTA);

            if (!srtfFinished)
                srtf.run(DELTA);

            if (!rrFinished)
                rr.run(DELTA);

            if (fcfsProcessesLeft == 0 && fcfs.getQueue().isEmpty() && !fcfsFinished) {
                fcfsCycles = currentTime;
                fcfsFinished = true;
            }
            if (srtfProcessesLeft == 0 && srtf.getQueue().isEmpty() && !srtfFinished) {
                srtfCycles = currentTime;
                srtfFinished = true;
            }
            if (rrProcessesLeft == 0 && rr.getQueue().isEmpty() && !rrFinished) {
                rrCycles = currentTime;
                rrFinished = true;
            }

            currentTime++;

        }

        System.out.println("===== FCFS =====");
        System.out.println("Finished in " + fcfsCycles + " cycles.");
        System.out.println("FCFS average execution time: " + ( fcfs.getData().totalExecutionTime / PROCESS_COUNT) );
        System.out.println("FCFS average waiting time: " + ( fcfs.getData().totalWaitingTime / PROCESS_COUNT) );
        System.out.println("===== SRTF =====");
        System.out.println("Finished in " + srtfCycles + " cycles.");
        System.out.println("SRTF average execution time: " + ( srtf.getData().totalExecutionTime / PROCESS_COUNT) );
        System.out.println("SRTF average waiting time: " + ( srtf.getData().totalWaitingTime / PROCESS_COUNT) );
        System.out.println("SRTF starving processes: " + srtf.getData().starvedProcesses);
        System.out.println("===== Round Robin =====");
        System.out.println("Finished in " + rrCycles + " cycles.");
        System.out.println("RR average execution time: " + ( rr.getData().totalExecutionTime / PROCESS_COUNT) );
        System.out.println("RR average waiting time: " + ( rr.getData().totalWaitingTime / PROCESS_COUNT) );
        System.out.println("RR average processor access time: " + ( rr.getData().totalProcessorAccessTime / PROCESS_COUNT) );
    }

    /**
     * Based on a seed returns a boolean value whether a process should be added or not.
     * @param seed a seed for RNG
     * @return {@code true} if number generated by RNG is larger than {@code ADDITION_THRESHOLD}
     */
    public static boolean shouldAddProcess(int seed) {
        Random r = new Random(seed + RANDOM_OFFSET);
        return r.nextFloat() > ADDITION_THRESHOLD;
    }

}
